# Контроллер, который делает всю работу в этом приложении
class XmlController < ApplicationController
  # Магия RoR - возможность вызвать какой-то метод до вызова одного
  # или нескольких методов контроллера.
  # первый параметр - какой метод вызываем
  # only значит, что вызываем ТОЛЬКО перед index.
  # Эта штука часто используется в рельсах, так что рекомендую приучаться)
 # before_action :parse_params, only: :index

  # Метод, принимающий запросы от приложения 2.
  # Мы не трогаем params, потому что перед ним вызвался (из-за before_action)
  # метод parse_params, который уже все за нас распарсил и разложил
  # по нужным переменным.
  def index
    @val = params[:val].to_i
    happyn = find_happy(@val)
    # Сформировали сообщение.
    # Очень удобно делать это в виде хэша - он умеет
    # превращаться в XML с нужными названиями тегов - ключами.
    data = if happyn.nil?
             { message: "Неверные параметры запроса (значение = #{@val})" }
           else
             happyn.map { |elem| { ind: happyn.index(elem) + 1, elem: elem } }
           end

    # Отвечаем клиенту.
    # .to_xml - это и есть формирование XML средствами ActiveSupport.
    # Насчет обработки в RSS мне самому не очень понятно. По-хорошему, тут надо
    # делать вьюху XML, в которую впихивать данные шаблонизатором и рендерить ее
    # с параметром layout: false, то, что возвращается сейчас - не RSS.
    # С другой стороны, RSS требуется проверять только в функциональном тесте, так что хз...
    respond_to do |format|
      format.xml { render xml: data.to_xml }
      format.rss { render xml: data.to_xml }
    end
  end

  protected

  # Раскидывает параметры запроса из хэша по переменным объекта.
  # Такой код используется для удобства и сокращения кода метода
  # контроллера, реализующего основную логику обработки запроса.
  #def parse_params

 # end

  private

  # Возвращает массив всех чисел от 0 до верхней границы.
  def find_happy(val)
    # В случае несоответствия типов ожидаемым возвращаем nil.
    if val < 0
      nil
    else
      (0..val).each.select { |x| sum?((x % 1000), (x / 1000)) }
    end
    # В случае несоответствия значений нижней и верхней границ возвращаем nil.
      # Преобразуем диапазон [lower, upper] в массив и оставляем в нем только
      # те числа, которые являются палиндромами.
  end

  # Проверяет, является ли число палиндромом.
  # @param x Integer число для проверки.
  # @return Bool
  def sum?(x, y)
    (x / 100 + (x % 100) / 10 + (x % 100) % 10) == (y / 100 + (y % 100) / 10 + (y % 100) % 10)
  end
end
